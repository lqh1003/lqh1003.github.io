---
title: 前端性能优化—实战思路
date: 2025-09-19 12:23:28
tags:
  - 性能优化
categories: 性能优化
cover: /images/前端性能优化—实战思路/cover.jpg # 封面图
---

- 打开速度怎么变快 —— 首屏加载优化
- 再次打开速度怎么变快 —— 缓存优化
- 操作怎么才顺滑 —— 渲染优化
- 动画怎么保证流畅 —— 长任务拆分

# 前端性能优化 —— 实战思路

## ⚙️ 开发一个 SEO 要求高、首屏加载快的新网站

- 首选终极方案：SSR 服务端渲染，静态站点生成 SSG

## ⚙️ 对一个现成的网站进行性能和 SEO 优化

### 性能指标衡量

- ⭐ FCP（First Contentful Paint）—— 用户导航到你页面后浏览器呈现第一块 DOM 内容所花费的时间
- ⭐ LCP（Largest Contentful Paint） —— 指页面渲染出最大文本或图片的时间
- SI（Speed Index） —— 指界面可见内容的显示速度
- TTI（Time to Interactive） —— 指网页需要多长时间才能提供完整的交互功能
- TBT（Total Blocking Time） —— 度量页面被阻止响应用户输入（如鼠标单击、屏幕点击或键盘按下）的总时间
  - 这个综合是通过在 FCP 和可交互时间之间添加所有长任务的阻塞部分来计算的
  - 任何执行时间超过 50ms 的任务都是长任务，50ms 后的时间量就是阻塞部分
- CLS（Cumulative Layout Shift） —— 指整个页面生命周期内发生的所有单次布局偏移分数的总和

![](/images/前端性能优化—实战思路/lighthouse-performance0.png) ![](/images/前端性能优化—实战思路/lighthouse-performance.png)

**Lighthouse** 的性能指标时间计算：其核心原理是利用浏览器提供的 Performance API（如 performance.timing、LCP 观察者等）和自定义追踪逻辑，结合页面加载的全生命周期数据进行计算得到的
![](/images/前端性能优化—实战思路/performanceapi.png)

### 先对网站本身性能优化

- #### 🖼️ 图片

  - 压缩 png → webp/avif (压缩质量 80%的用户看不出，可接受)

    - 手动转换项目中较大图片的格式，[图片格式转换](https://squoosh.app/, '图片格式转换在线工具')
    - 项目中 **批量** 将图片格式修改为 Webp

      - 安装转换工具：
        - Windows：使用 Google 官方的 cwebp 工具（高效且支持批量处理）
          - 从 [WebP 官网](https://developers.google.com/speed/webp/download?hl=zh-cn) 下载工具包
          - 解压后，在`bin`目录下可以看到`cwebp.exe`（这是核心转换工具）
          - 配置环境变量：在「系统变量」中找到 Path 变量，双击打开 → 输入`cwebp.exe`所在的`bin`目录路径
            ![](/images/前端性能优化—实战思路/path_cwebp.png)
          - 重新打开 cmd，输入`cwebp -version`显示版本则配置成功
        - Mac：`brew install webp`
        - Linux：`sudo apt install webp`
      - 批量转换图片为 WebP 格式 （全局图片 WebP 化，同时保证兼容性，通常能减少 `40%-60%` 的图片体积）

        - 先手动备份图片（关键!!!），防止转换失败导致文件丢失
        - **编写批量转换脚本**，确保路径与项目图片目录一致

          - Mac/Linux 脚本（convert-webp.sh）—— 自行搜索
          - **Windows 脚本（`convert-webp.bat`）**

          ```bat
          @echo off
          setlocal enabledelayedexpansion

          :: 图片源目录（根据项目实际路径修改：脚本文件 .bat 与路径第一层的 src 放在同一目录）
          set "IMG_DIR=src\assets\images"

          :: 检查目录是否存在
          if not exist "%IMG_DIR%" (
            echo 错误：目录 %IMG_DIR% 不存在！
            pause
            exit /b 1
          )

          :: 递归转换所有图片
          for /r "%IMG_DIR%" %%i in (*.jpg, *.jpeg, *.png) do (
            set "output=%%~dpni.webp"
            cwebp -q 80 -m 6 "%%i" -o "!output!"

            :: 检查转换结果
            if exist "!output!" (
              echo ✅ 转换成功：!output!
            ) else (
              echo ❌ 转换失败：%%i
            )
          )

          :: 删除原图（可选）：确认转换无误后，删除原 jpg/png 文件（节省空间）
          :: del /s /q src\assets\images\*.jpg
          :: del /s /q src\assets\images\*.jpeg
          :: del /s /q src\assets\images\*.png

          echo 批量转换完成！
          pause
          ```

        - 执行脚本，会在原图片同目录生成 .webp 文件

          - Mac/Linux：终端进入项目根目录，运行 chmod +x convert-webp.sh && ./convert-webp.sh。
          - Windows：**双击 `convert-webp.bat` 运行**（或在 cmd 中执行）
            ![](/images/前端性能优化—实战思路/double_webp.png)

        - 项目中图片全部替换 webp 格式（.vue/.js/.ts/.css 等文件：仔细检查所有的图片）

          - 搜索内容：(`\.jpg|\.jpeg|\.png`)（正则匹配原扩展名） → 替换内容：.webp

        - 兼容性处理（关键）

          - WebP 在 IE、老旧安卓浏览器中不兼容，需使用 `<picture>` 标签自动降级

        - 清理原图，打开清理原图的代码，在执行一遍 `convert-webp.bat`，验证页面效果

    - 项目使用 Vite 或 Webpack，可通过插件实现 **开发 / 构建时自动转换**
      - 安装插件：`npm i vite-plugin-webp -D`、`npm i image-webpack-loader file-loader -D`
      - 在配置文件中配置：`vite.config.js`、`webpack.config.js`

  - 上传图片功能：图片上传前先进行压缩，控制的压缩图片的尺寸大小

    - 比如：上传头像、 业务后台上传配置 app 上新闻/轮播图等模块的图片，都不需要太大尺寸
    - 下载依赖：`browser-image-compression`

    ```javascript
    import imageCompression from 'browser-image-compression'
    // 上传图片
    const getResoureUrl = () => {
    	nextTick(() => {
    		const resoUp = document.getElementById('IMGUpload')
    		if (!resoUp) return
    		resoUp.value = ''
    		resoUp.onchange = null
    		resoUp?.click()

    		resoUp.onchange = async function (event) {
    			const upFile = event.target.files[0] // 获取文件对象
    			if (!upFile) return

    			// ******* 压缩图片 *********
    			const options = {
    				maxSizeMB: 1, // 最大文件大小(MB)
    				maxWidthOrHeight: 500, // （压缩后的）最大宽/高
    				useWebWorker: true, // 使用WebWorker加速
    				fileType: 'image/webp', // 可选转换为webp格式
    			}
    			const compressedFile = await imageCompression(upFile, options)
    			// 使用压缩后的文件或原文件
    			const file = compressedFile || upFile

    			// ******* 对拿到的 file 进行处理 *********
    		}
    	})
    }
    ```

  - 精灵图（[制作精灵图](https://www.toptal.com/developers/css/sprite-generator, '在线合成精灵图工具')）
  - svg 矢量图，直接使用，体积小
  - 避免"大图小用"，按照分辨率显示不同尺寸的图片(1/2/3 倍图)（srcset + sizes）

  ```html
  <img
  	src="pic-800.jpg"
  	srcset="pic-400.jpg 400w, pic-800.jpg 800w"
  	sizes="(max-width: 600px) 400px, 800px"
  />
  ```

- #### 🎬 视频

  - 用 `MP4`（H.264）或 WebM（更小）
  - 避免加载全高清视频，按需加载 "自适应分辨率"
  - 视频上传前压缩（视频压缩会降低文件大小，但可能影响画质；建议根据需求调整参数，压缩过程在浏览器中完成，不会上传到服务器）
  - ...

- #### 🧩 三方库优化

  - 对大体积第三方库（如 Excel 处理、图表库），按需加载其子模块（如：`import { Line } from 'chart.js'`）
  - 或用更轻量的替代库（如用 `dayjs` 替代 `moment.js`）

- #### 📦 代码压缩

  - **原生 html 项目**，使用压缩版本的 min.js 文件
  - **vue 项目**

    - 手动压缩 Terser，直接在 vue.config.js 文件中配置即可（配置 Terser 压缩 + Tree Shaking 摇树优化）

      - 通过混淆、删除空格、合并语句、移除不需要的代码等方式，显著减小生产环境的 JS 包体积

      ```javascript
      const { defineConfig } = require('@vue/cli-service')
      module.exports = defineConfig({
      	publicPath: './',
      	outputDir: 'distTerser',
      	assetsDir: 'static',
      	devServer: {},

      	// 生产环境下启用 sourceMap（可选，关闭可进一步减小体积）
      	productionSourceMap: false,
      	// 配置 webpack 优化项
      	configureWebpack: {
      		// 启用 Tree-Shaking（生产环境开启，开发环境无需压缩）
      		optimization:
      			process.env.NODE_ENV === 'production'
      				? {
      						// 1. 摇树优化核心配置
      						usedExports: true, // 标记未使用的导出，为摇树提供依据
      						sideEffects: true, // 识别 package.json 中的 sideEffects 字段，避免误删有副作用的代码
      						// 压缩配置
      						minimizer: [
      							// 2. 配置压缩工具（Terser）：压缩代码 + 彻底移除死代码
      							new (require('terser-webpack-plugin'))({
      								// 压缩选项
      								terserOptions: {
      									// 删除注释（生产环境推荐开启）
      									output: {
      										comments: false,
      									},
      									// 压缩策略配置
      									compress: {
      										// 移除 console（可选，根据需求决定）
      										drop_console: true,
      										// 移除 debugger
      										drop_debugger: true,
      										// 合并重复代码
      										collapse_vars: true,
      										// 提取公共代码到变量
      										reduce_vars: true,
      										// 移除未使用的变量和函数（摇树的最终执行环节）
      										unused: true,
      									},
      								},
      								// 删除所有注释（包括 LICENSE 等）
      								extractComments: false,
      							}),
      						],
      						// 3. 分割代码（可选，进一步提升压缩效率）
      						splitChunks: {
      							chunks: 'all',
      							cacheGroups: {
      								// 提取 node_modules 中的公共库
      								vendor: {
      									test: /[\\/]node_modules[\\/]/,
      									name: 'vendors',
      									chunks: 'all',
      								},
      							},
      						},
      				  }
      				: {},
      	},
      })
      ```

    - 自动压缩：利用 Gzip、Brotil 打包压缩，前端配置 Gzip 压缩，服务器端开启支持 Gzip 即可

      - 安装依赖：`compression-webpack-plugin`
      - 在 `vue.config.js` 中配置 Gzip 压缩

      ```javascript
      const { defineConfig } = require('@vue/cli-service')
      const CompressionPlugin = require('compression-webpack-plugin')
      module.exports = defineConfig({
          publicPath: './',
          outputDir: 'distTerser',
          assetsDir: 'static',
          devServer: {},

          // 配置 webpack 优化项
          configureWebpack: {
            optimization:
              process.env.NODE_ENV === 'production'
                ? {
                    // 压缩配置
                    minimizer: [
                      new CompressionPlugin({
                        filename: '[path][base].gz', // 必须指定输出文件名格式（关键）
                        test: /\.(js|css|html|svg)$/, // 匹配需要压缩的文件类型
                        algorithm: 'gzip', // 使用 gzip 算法
                        threshold: 5120, // 5KB 以上才压缩
                        minRatio: 0.8, // 压缩率小于 0.8 才保留
                        deleteOriginalAssets: false, // 保留原文件（避免服务器不支持 gzip 时出错）
                      }),
                    ],
                : {},
            },
          })
      ```

      - `npm run build` 生产环境打包，触发压缩逻辑
      - 验证是否生效：进入 `dist/js` 或 `dist/css` 目录，查看是否有 .gz 文件
      - 此时直在本地双击运行 `dist/index.html`（`以 file:// 协议打开`）时，gzip 压缩的 .gz 文件无法被浏览器正常解析，会导致页面加载失败或 JS/CSS 等资源无法解析
        - 这是因为本地运行不具备服务器环境，不支持 gzip 解压（报错 "语法错误" 或 "资源无法加载"），无法处理 gzip 压缩文件的解压逻辑
      - 服务器配置
        - 仅仅在前端打包生成 .gz 文件还不够，还需要服务器配置支持 Gzip 压缩
          ```bash
            # Nginx 配置示例
            gzip on;
            gzip_types text/css application/javascript image/svg+xml text/html;
            gzip_min_length 10k;
            gzip_comp_level 5;
          ```
      - 检查服务器部署是否生效，部署后，通过浏览器开发者工具的 Network 面板查看
        - 响应头中是否有 `Content-Encoding: gzip`（数据的压缩格式）
        - 查看文件大小是否有明显减小

  - 📌【注意】Gzip 压缩（`compression-webpack-plugin`）和 Terser 压缩（`terser-webpack-plugin`）完全不冲突，两者的优化方向不同：

    - Terser：对 JS 代码进行语法级压缩（删除注释、混淆变量、合并语句等），生成更小的 JS 文件
    - Gzip：对打包后的静态资源（包括 JS、CSS、HTML 等）进行二进制级压缩，进一步减小传输体积

    - 两者可以同时启用，且搭配使用效果更好（**先经 Terser 压缩 JS，再经 Gzip 压缩所有资源**），二者协同工作，先优化代码结构，再压缩传输体积，最终实现 `60%-80%` 的资源体积缩减，显著提升 Lighthouse 性能评分

  - 📌 `Transfer-Encoding: chunked` 和 `Content-Encoding: gzip`

    - 分块传输（`Transfer-Encoding: chunked`）：通常由服务器自动配置，用于在无法预先确定响应数据总大小的场景（如动态生成内容、流式传输）
    - `Content-Encoding: gzip` （数据的压缩格式）

    | 对比维度         | `Transfer-Encoding: chunked`           | `Content-Encoding: gzip`           |
    | :--------------- | :------------------------------------- | :--------------------------------- |
    | 核心目           | 解决「数据大小未知时如何传输」的问题   | 解决「如何减小数据                 |
    | 对数据的影响     | 不改变数据内容，仅改变传输方式         | 改变数据格式（压缩），需客户端解压 |
    | 依赖关系         | 与数据是否压缩无关                     | 可与分块传输结合使用               |
    | 客户端处理方式   | 自动拼接分块，还原为完整数据           | 自动解压，还原为原始数据           |

- #### ⏳ 延迟加载

  - 懒加载

    - vue 组件/路由懒加载：`const Home = () => import('./views/Home.vue');`
    - 视频/图片/iframe 懒加载：
      - 原生支持的 lazy 属性 `<img src="image.webp" alt="..." loading="lazy">` （旧浏览器不支持）
      - 使用 IntersectionObserver API（推荐，现代方案），通过 data-src 占位，监听元素进入视口后替换真实地址 `<img data-src="image.webp" alt="..." class="lazy">`
      - 点击后再动态创建`<video>/<img>`标签或赋值 src，比如：先展示缩略图点击后查看清晰图、非自动播放的视频(先展示图片，点击后再播放)
    - 脚本（JS）延迟加载，延迟动态创建` <script>` 标签，或使用 `async/defer` 异步加载

  - 按需加载：加载首屏需要的资源(css、Font、js 等)

- #### 🔗 预加载

  - 预加载关键资源 `<link rel="preload" href="hero-banner.webp" as="image" type="image/webp">`

    - href，指定资源的路径
    - as，指定资源类型（如 font、script、image、style、audio、video），决定浏览器的加载优先级和处理逻辑；若省略，浏览器会以低优先级加载为 "通用资源"
    - type，指定 MIME 类型（如 font/woff2、image/jpeg），浏览器可提前判断是否支持该资源，避免无效加载
    - crossorigin，加载跨域资源（如字体）时必需，否则资源加载后无法被页面使用

  - 预加载的适用场景
    - 图片画廊 / 轮播图：预加载下一张 / 下一组图片，实现无缝切换
    - 单页应用（SPA）：路由切换前预加载目标页面的 JS/CSS，消除切换时的白屏
    - 多媒体内容：视频 / 音频播放前预加载部分内容，避免播放缓冲
    - 导航菜单：预加载热门导航对应的页面资源（如：电商的 "购物车"，"订单" 页面）
    - 字体资源：预加载自定义字体，解决 "无样式文本闪烁（FOIT）" 问题

- #### 🐘 缓存优化

  前端缓存是性能优化的核心手段之一，其本质是**将频繁访问的资源（如静态文件、接口数据）存储在本地或中间层，避免重复请求与传输，从而降低延迟、减少带宽消耗、提升页面加载速度**
  前端缓存体系可分为 浏览器缓存（客户端缓存）、HTTP 缓存（服务端与客户端协同）和应用层缓存（前端代码层面控制）三大类

  - HTTP 缓存（强缓存、协商缓存）

    - 后端配置（核心）：在响应头中返回这些字段
      | 对比维度   | 强缓存 (Strong Cache) | 协商缓存 (Conditional Cache)     |
      | :----------- | :---------------------------------- | :------------------------ |
      | 核心逻辑   | 本地判断有效则直接用，不发请求   | 必发请求，服务器判断是否用缓存   |
      | 关键响应头 | `Cache-Control`(优先级高)、`Expire`  | `Last-Modified`/`ETag `  |
      | 网络请求 | 未过期时无请求   | 始终发请求（响应体可能为空）  |
      | 命中状态码 | 200 (from cache)   | 304 Not Modified  |
      | 更新灵活性 | 低（未过期不更新） | 高（服务器实时控制）  |
      | 服务器压力 | 无   | 有（需处理判断请求）   |
      | 适用场景   | 更新慢的静态资源（图、JS/CSS 包）   | 动态资源、更新频繁的静态资源   |

    - 前端配置（配合后端）：前端通过 **资源命名策略** 和 **请求头控制** 配合后端缓存策略，确保缓存有效性

      - 静态资源版本化（解决缓存更新问题）
        - 方案 1：文件名加哈希（推荐）
        ```html
        <!-- 构建工具（Webpack/Vite）自动生成带哈希的文件名 -->
        <link rel="stylesheet" href="style.8f2b7.css" />
        <script src="app.a3d9c.js"></script>
        ```
        - 方案 2：URL 参数（不推荐，部分代理服务器不识别）
        ```html
        <img src="logo.png?v=202409" />
        ```
      - 动态资源 / API 缓存控制，比如：axios、fetch 中实现请求缓存
        - 默认情况下不缓存
        - cacheTime：60, // 缓存时间，60s
        - noCache: true, // 强制不使用缓存
        - 使用第三方缓存库（如 axios-cache-adapter）
        - ...

  - 浏览器缓存
    - localStorage
    - sessionStorage
    - Cookies
    - IndexedDB（本地数据库）
  - 应用缓存 —— 前端代码层面的 "逻辑缓存"
    - keep-alive 页面缓存
    - 计算属性 computed 有缓存
    - ...
  - Service Worker（离线缓存）
  - 服务端辅助缓存（CDN 与代理缓存）

- #### 🚀 动画卡顿优化
  - 卡顿和核心原因：动画触发了「布局」或「绘制」阶段，涉及重新计算，消耗较大
  - 为什么会卡顿，**单线程**， 阻塞主线程，减少长任务
  - 优化：
    - 用 css 的位移 transform/过渡 transition/动画 animation 代替 js 计算直接操作 ODM
    - 减少对 DOM 的操作
    - 优化 js 代码，做好防抖/节流等
    - 更换合适的动画方案
      | 动画方案   | 性能级别 | 适用场景     | 注意事项     |
      | :------------- | :---------------- | :---------------------- |:------------------------- |
      | CSS`transform/opacity`   |  5 星 | 基础位移、缩放、旋转、透明度动画   | 仅支持简单动画，逻辑复杂时需配合 JS |
      | CSS`@keyframes`   |  4 星 |   关键帧动画（如循环闪烁、路径固定） | 避免在关键帧中使用布局属性|
      | JS`requestAnimationFrame`   | 4 星   | 复杂交互动画（如跟随鼠标、数据驱动）  |避免回调中做耗时计算 |
      | Canvas 动画   | 3 星 |大量元素动画（如粒子效果、图表） | 需手动优化重绘区域，避免全量重|
      | SVG 动画   |  2 星 | 矢量图形动画（如图标动效）   | 复杂 SVG 易触发高频绘制，性能较差 |
      | 三方动画库   | | [aos](https://michalsnik.github.io/aos/)、[gsap](https://gsap.com/) 等|

### 再对外部因素进行优化

- CDN 分发静态资源
  将 JS、CSS、图片等静态资源部署到 CDN（如 Cloudflare、阿里云 CDN），用户从最近的节点加载，减少网络延迟（尤其跨地区用户）

- **启用 HTTP/2 或 HTTP/3**

  - HTTP/2：支持多路复用（同一连接并发请求），解决 HTTP/1.1 的队头阻塞问题
  - HTTP/3：基于 QUIC 协议（UDP），进一步优化丢包恢复和连接建立速度
