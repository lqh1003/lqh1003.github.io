---
title: Event事件循环
date: 2025-07-29 10:51:52
tags: event loop
categories: Javascript
cover: /images/Event事件循环/cover.jpg # 封面图
---

```javascript
console.log('Start')
setTimeout(() => {
	console.log('Timeout1')
}, 10000)
Promise.resolve().then(() => {
	console.log('Promise1')
})
setTimeout(() => {
	console.log('Timeout2')
}, 0)
const timmer = setInterval(() => {
	console.log('Interval')
}, 3000)
Promise.resolve().then(() => {
	console.log('Promise2')
})
console.log('End')
clearInterval()
```

- 问题：请解释上述代码的执行顺序，为什么会按照这样的顺序输出结果？

---

- Event Loop：在事件循环机制中，任务分为 微任务(Promise 回调、DOM 变化监听等) 和 宏任务(setTimeout/setInterval、DOM 事件回调 click/scroll 等)

- 解答：
  - 代码开始执行，首先输出 `Start`
  - 遇到  `setTimeout(() => { console.log('Timeout1'); }, 10000)`，它会在 10 秒后将回调函数  () => { console.log('Timeout1'); }  放入宏任务队列
  - 接着  `Promise.resolve().then(() => { console.log('Promise1'); })`，Promise.resolve()  会返回一个已解决的  Promise  对象，其  then  方法里的回调函数  () => { console.log('Promise1'); }  会被添加到微任务队列
  - 再碰到 `setTimeout(() => { console.log('Timeout2'); }, 0)`，尽管延迟时间设为 0 毫秒，在 0 秒把回调函数  () => { console.log('Timeout2'); }  放入宏任务队列
  - 之后是 `setInterval(() => { console.log('Interval'); }, 3000)`，它会在 3 秒后将回调函数  () => { console.log('Interval'); }  放入宏任务队列，并且之后每隔 3 秒放入一次
  - 又遇到 `Promise.resolve().then(() => { console.log('Promise2'); })`，then  方法的回调函数  () => { console.log('Promise2'); }  会被加入微任务队列
  - 接着输出 `End`
  - 接着执行 `clearInterval()` (clearInterval 是同步)，无任何入参，所以它不会清除任何定时器，也不会抛出错误
  - **当主线程的同步代码执行完后，事件循环会优先处理微任务队列**，会输出  Promise1、接着输出 Promise2
  - **微任务队列处理完毕后，事件循环会从宏任务队列中取出任务执行**，所以最后输出 Timeout2、3 次 Interval、Timeout1、n 次 Interval
  - 综上所述，代码的输出顺序为 `Start、End、Promise1、Promise2、Timeout2、Interval、Interval、Interval、Timeout1、Interval、Interval、Interval...`
