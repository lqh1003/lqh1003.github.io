---
title: js判断数据类型
date: 2025-07-23 15:20:50
tags:
categories: Javascript
---

### typeof A 判断数据类型

```javascript
// 基础数据类型：数字、字符串、布尔值、未定义、空值、Symbol(ES6新增)、BigInt(ES2020新增)
console.log(typeof 42) // "number"
console.log(typeof 'Hello, world!') // "string"
console.log(typeof true) // "boolean"
console.log(typeof undefined) // "undefined"
console.log(typeof null) // "object" (这是一个历史遗留问题)
console.log(typeof Symbol('symbol')) // "symbol"
console.log(typeof 123n) // "bigint"

// 引用数据类型：普通对象、数组、函数、new Date()等
console.log(typeof { name: 'Alice', age: 25 }) // "object"
console.log(typeof [1, 2, 3]) // "object"
console.log(typeof new Date()) // "object"
console.log(typeof function () {} || typeof new Function()) // "function" (特殊)
```

【注意】

- 基础数据类型：typeof 返回对应类型，除了 null，typeof null 返回"object"是一个 JS 的历史遗留问题
- 数组 Array/函数 Function/new Date()/new RegExp()/new XXX 等都属于对象类型范畴，属于广义的"对象"，但不是狭义的"普通对象"，所以 typeof 判断类型都返回"object"，除了函数 Function
- JavaScript 为了突出函数的"可执行性"和简化类型判断而做的特殊设计 —— 函数本质上是一种"可调用的对象"，但 typeof 刻意返回"function"来强调其特殊性

### A instanceof B 判断数据类型

- instanceof  用于判断一个对象是否是另一个对象的实例
- instanceof  对于内置对象类型和自定义类都有效
- instanceof  对于原始类型无效，但可以通过构造函数包装对象进行判断

```javascript
// 创建一个构造函数
function Person(name) {
	this.name = name
}
// 创建一个实例
const alice = new Person('Alice')
// 判断实例与构造函数的关系
console.log(alice instanceof Person) // true

// 判断内置对象类型
console.log([] instanceof Array) // true
console.log({} instanceof Object) // true
console.log(new Date() instanceof Date) // true
console.log(/regex/ instanceof RegExp) // true
// 自定义类
class Animal {}
class Dog extends Animal {}
const myDog = new Dog()
console.log(myDog instanceof Dog) // true
console.log(myDog instanceof Animal) // true
console.log(myDog instanceof Object) // true

// 注意 `instanceof` 只对对象有效，对原始类型无效
console.log(42 instanceof Number) // false
console.log('Hello' instanceof String) // false
console.log(true instanceof Boolean) // false

// 对于原始类型，可以使用构造函数包装对象进行判断
console.log(new Number(42) instanceof Number) // true
console.log(new String('Hello') instanceof String) // true
console.log(new Boolean(true) instanceof Boolean) // true
null instanceof null // 控制台报错：右侧不是对象
```

### Array.isArray(value)：专门用于判断一个值是否为数组

```javascript
// 数组
console.log(Array.isArray([1, 2, 3])) // true
// 对象
console.log(Array.isArray({ name: 'Alice', age: 25 })) // false
// 字符串
console.log(Array.isArray('Hello, world!')) // false
// 数字
console.log(Array.isArray(42)) // false
// 布尔值
console.log(Array.isArray(true)) // false
// null
console.log(Array.isArray(null)) // false
// undefined
console.log(Array.isArray(undefined)) // false
// 函数
console.log(Array.isArray(function () {})) // false
// Date 对象
console.log(Array.isArray(new Date())) // false
// 正则表达式
console.log(Array.isArray(/regex/)) // false
```

### 判断是否为数组的方法

- 推荐使用 Array.isArray(arr)方法，它是最简洁和可靠的，Es6 专门为此设计的方法
- A instanceof B
  const value = [1, 2, 3];
  console.log(value instanceof Array); // true
- Object.prototype.toString，是一种老方法，通常不再推荐使用
  const value = [1, 2, 3];
  console.log(Object.prototype.toString.call(value) === '[object Array]'); // true

### Object.is(a,b)

- 在 JavaScript 中用于判断两个值是否严格相等。它与===（严格相等）有一些细微的区别

```javascript
// 数字
console.log(Object.is(42, 42)) // true
console.log(Object.is(0, -0)) // false
console.log(Object.is(NaN, NaN)) // true
// 字符串
console.log(Object.is('hello', 'hello')) // true
console.log(Object.is('hello', 'world')) // false
// 布尔值
console.log(Object.is(true, true)) // true
console.log(Object.is(true, false)) // false
// 对象
const obj1 = { a: 1 }
const obj2 = { a: 1 }
console.log(Object.is(obj1, obj1)) // true
console.log(Object.is(obj1, obj2)) // false
// 数组
const arr1 = [1, 2, 3]
const arr2 = [1, 2, 3]
console.log(Object.is(arr1, arr1)) // true
console.log(Object.is(arr1, arr2)) // false
// undefined 和 null
console.log(Object.is(undefined, undefined)) // true
console.log(Object.is(null, null)) // true
console.log(Object.is(undefined, null)) // false
// 不同类型
console.log(Object.is(42, '42')) // false
console.log(Object.is(true, 1)) // false
console.log(Object.is({}, [])) // false
```

总结：

- Object.is  方法用于判断两个值是否严格相等
- 与  ===  的主要区别是：Object.is  认为  +0  和  -0  不相等，而认为  NaN  和  NaN  相等
